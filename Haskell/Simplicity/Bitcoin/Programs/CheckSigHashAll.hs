-- | The module builds a Simplicity expression that mimics the behavour of a @CHECKSIG@ operation restricted to a @SIGHASH_ALL@ flag, for Bitcoin.
-- This forms the mimial Simiplicity expression needed to secure funds in a Bitcoin-like blockchain.
-- This uses Schnorr signature verification specified in "Simplicity.Programs.LibSecp256k1".
module Simplicity.Bitcoin.Programs.CheckSigHashAll
  ( sigHashAll
  , checkSigHashAll
  , wCheckSigHashAll
  , pkwCheckSigHashAll
  ) where

import qualified Data.ByteString.Char8 as BSC

import Simplicity.Digest
import Simplicity.MerkleRoot
import qualified Simplicity.LibSecp256k1.Schnorr as Schnorr
import Simplicity.Bitcoin.Primitive
import Simplicity.Bitcoin.Term
import Simplicity.Programs.Bit
import Simplicity.Programs.Generic
import Simplicity.Programs.Sha256
import Simplicity.Programs.LibSecp256k1
import Simplicity.Programs.Word
import Simplicity.Ty

-- | This expression returns a hash of basic signed transaction data.
-- This includes:
--
-- * Hash of all the transaction inputs data.
--
-- * Hash of all the transaction output data.
--
-- * The index of the input currently being spend.
--
-- * The value of this input.
--
-- * The transactions lock time.
--
-- * The transactions version data.
sigHashAll :: (Core term, Primitive term) => term () Hash
sigHashAll = sigAll >>> (scribe iv &&& oh >>> hashBlock) &&& ih >>> hashBlock
 where
  iv = toWord256 . integerHash256 . ivHash $ signatureIv (commitmentRoot sigAll)
  sigAll :: (Core term, Primitive term) => term () (Block, Block)
  sigAll = blk1 &&& blk2
   where
    blk1 = primitive InputsHash &&& primitive OutputsHash
    blk2 = ((primitive CurrentValue &&& (primitive CurrentIndex &&& primitive LockTime)) &&& ((primitive Version &&& scribe (toWord32 0x80000000)) &&& zero word64)) &&& scribe (toWord256 (512+2*256+64+3*32))

-- | Given a public key and a schnorr signature, this expression asserts that the signature is valid for the public key and the message generated by 'sigHashAll'.
checkSigHashAll :: (Assert term, Primitive term) => term (PubKey, Sig) ()
checkSigHashAll = (oh &&& (unit >>> sigHashAll)) &&& ih
              >>> schnorrAssert

-- | Given a public key this expression asserts that the given witness is a signature that is valid for the public key and the message generated by 'sigHashAll'.
wCheckSigHashAll :: (Assert term, Primitive term, Witness term) => Schnorr.Sig -> term PubKey ()
wCheckSigHashAll (Schnorr.Sig r s) = iden &&& (witness (toWord256 . toInteger $ r, toWord256 . toInteger $ s))
                                 >>> checkSigHashAll

-- | Given a static public key this expression asserts that the given witness is a signature that is valid for the public key and the message generated by 'sigHashAll'.
pkwCheckSigHashAll :: (Assert term, Primitive term, Witness term, TyC a) => Schnorr.PubKey -> Schnorr.Sig -> term a ()
pkwCheckSigHashAll (Schnorr.PubKey y x) (Schnorr.Sig r s) =
   scribe (toBit y, toWord256 . toInteger $ x) &&& (witness (toWord256 . toInteger $ r, toWord256 . toInteger $ s))
   >>> checkSigHashAll
