-- | The module builds a Simplicity expression that mimics the behavour of a @CHECKSIG@ operation restricted to a @SIGHASH_ALL@ flag, for Elements.
-- This forms the mimial Simiplicity expression needed to secure funds in a Elements-style blockchain.
-- This uses Schnorr signature verification specified in "Simplicity.Programs.LibSecp256k1".
module Simplicity.Elements.Programs.CheckSigHashAll
  ( sigAllCMR
  , sigHashAll
  , checkSigHashAll
  , wCheckSigHashAll
  , pkwCheckSigHashAll
  ) where

import Prelude hiding (drop, take)
import qualified Data.ByteString.Char8 as BSC

import Simplicity.Digest
import Simplicity.MerkleRoot
import qualified Simplicity.LibSecp256k1.Schnorr as Schnorr
import Simplicity.Elements.Primitive
import Simplicity.Elements.Term
import Simplicity.Programs.Bit
import Simplicity.Programs.Generic
import Simplicity.Programs.Sha256
import Simplicity.Programs.LibSecp256k1
import Simplicity.Programs.Word
import Simplicity.Ty

-- | This expression returns a hash of basic signed transaction data.
-- This includes:
--
-- * Hash of all the transaction inputs data.
--
-- * Hash of all the transaction output data.
--
-- * The transactions lock time.
--
-- * The transactions version data.
--
-- * The index of the input currently being spend.
--
-- * The asset and amount of this input's UTXO being redeemed.
sigAll :: (Core term, Primitive term) => term () (Block, (Block, Either () Block))
sigAll = blk1 &&& (blk2andMaybe3)
 where
  curAsset = (primitive CurrentAsset &&& unit) >>>
             (match (take (cond (scribe (toWord8 11) &&& iden) (scribe (toWord8 10) &&& iden)))
                    (scribe (toWord8 1) &&& oh))
         >>> ((((oh &&& drop (take (take oooh))) &&& drop (take (take (take (oih &&& ioh))))) &&&
              drop (take (take  ((oiih &&& iooh) &&& drop (oih &&& ioh)) &&& ((take iiih &&& drop oooh) &&& drop (take (oih &&& ioh)))) &&&
                     (take (drop ((oiih &&& iooh) &&& drop (oih &&& ioh))) &&& ((take (drop iiih) &&& drop (take oooh)) &&& drop (take (take (oih &&& ioh))))))) &&&
              drop (drop ((take ((oiih &&& iooh) &&& drop (oih &&& ioh)) &&& ((take iiih &&& drop oooh) &&& drop (take (oih &&& ioh)))) &&&
                    drop  (((oiih &&& iooh) &&& drop (oih &&& ioh)) &&&   iiih))))
  curAmt = (primitive CurrentAmount &&& unit) >>>
           match (take curConfAmt) (take curExplAmt)
   where
    curExplAmt = ((scribe (toWord8 1)) &&& ooh) &&&
                 ((((oih &&& ioh) &&& (iih &&& (scribe (toWord16 0x8000)))) &&& scribe (toWord64 (512+2*256+3*32+8+256+8+64))) &&&
                 injl unit)
    curConfAmt = (oh &&& drop (take oooh) >>> cond (scribe (toWord8 9) &&& iden) (scribe (toWord8 8) &&& iden)) &&&
                 drop ((take (take (oih &&& ioh) &&& (oiih &&& iooh)) &&& (take (drop (oih &&& ioh)) &&& (take iiih &&& drop oooh))) &&&
                 drop (injr ((((take (oih &&& ioh) &&& (oiih &&& iooh)) &&& drop ((oih &&& ioh) &&& (iih &&& (scribe (toWord16 0x8000))))) &&& zero word128) &&& scribe (toWord256 (512+2*256+3*32+8+256+8+256)))))
  blk1 = primitive InputsHash &&& primitive OutputsHash
  blk2andMaybe3 = (curAsset &&& curAmt) >>>
              ((take (take (((unit >>> ((primitive Version &&& primitive LockTime))) &&& (((unit >>> primitive CurrentIndex) &&& oh))) &&& ih)) &&&
                 ((oioh &&& (take iioh &&& ((take iiih &&& iooh) &&& ioih))) &&& iioh)) &&& iiih)

sigAllCMR :: Hash256
sigAllCMR = commitmentRoot sigAll

sigHashAll :: (Core term, Primitive term) => term () Hash
sigHashAll = sigAll >>> (iih &&& ((scribe iv &&& oh >>> hb) &&& ioh >>> hb))
                    >>> match (drop iden)
                              ((ih &&& oh) >>> hb)
 where
  hb = hashBlock
  iv = toWord256 . integerHash256 . ivHash $ signatureIv sigAllCMR

-- | Given a public key and a schnorr signature, this expression asserts that the signature is valid for the public key and the message generated by 'sigHashAll'.
checkSigHashAll :: (Assert term, Primitive term) => term (PubKey, Sig) ()
checkSigHashAll = (oh &&& (unit >>> sigHashAll)) &&& ih
              >>> schnorrAssert

-- | Given a public key this expression asserts that the given witness is a signature that is valid for the public key and the message generated by 'sigHashAll'.
wCheckSigHashAll :: (Assert term, Primitive term, Witness term) => Schnorr.Sig -> term PubKey ()
wCheckSigHashAll ~(Schnorr.Sig r s) = iden &&& (witness (toWord256 . toInteger $ r, toWord256 . toInteger $ s))
                                 >>> checkSigHashAll

-- | Given a static public key this expression asserts that the given witness is a signature that is valid for the public key and the message generated by 'sigHashAll'.
pkwCheckSigHashAll :: (Assert term, Primitive term, Witness term, TyC a) => Schnorr.PubKey -> Schnorr.Sig -> term a ()
pkwCheckSigHashAll (Schnorr.PubKey y x) ~(Schnorr.Sig r s) =
   scribe (toBit y, toWord256 . toInteger $ x) &&& (witness (toWord256 . toInteger $ r, toWord256 . toInteger $ s))
   >>> checkSigHashAll
